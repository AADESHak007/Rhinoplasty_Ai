import { NextRequest, NextResponse } from "next/server";
import cloudinary from "@/lib/cloudinary";
import type { UploadApiResponse } from "cloudinary";
import { prisma } from "@/lib/prisma";
import { getCurrentUser } from "@/lib/auth-helper";

export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData();
    const file = formData.get("file") as File;
    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    // 1. Generate mask using the /api/mask-image route with FormData
    const maskFormData = new FormData();
    maskFormData.append('file', file);

    // "https://rhinoplasty-ai-iota.vercel.app/api/mask-image --  http://localhost:3000/api/mask-image" 

    const maskResponse = await fetch(`${process.env.NEXT_PUBLIC_SITE_URL}/api/mask-image`, {
      method: 'POST',
      body: maskFormData,
    });
    if (!maskResponse.ok) {
      throw new Error('Mask generation failed');
    }
    
    const maskData = await maskResponse.json();
    const maskImageUrl = maskData.maskUrl;
    if (!maskImageUrl) {
      throw new Error('No mask returned from mask generation ,Please try again !!!');
    }
    console.log("masked Image data",maskImageUrl) // got the URL generated by the model

    // 2. Upload original image to Cloudinary
    const uploadOriginal = await new Promise<UploadApiResponse>((resolve, reject) => {
      const stream = cloudinary.uploader.upload_stream(
        { folder: "rhinoplasty", resource_type: "image" },
        (err, result) => {
          if (err) reject(err);
          else resolve(result as UploadApiResponse);
        }
      );
      
      // Convert File to Buffer for cloudinary
      file.arrayBuffer().then(buffer => {
        stream.end(Buffer.from(buffer));
      }).catch(reject);
    });

    // 3. Upload mask image to Cloudinary (fetch from URL)
    
//     const maskResponse2 = await fetch(maskImageUrl);
//     if (!maskResponse2.ok) {
//       throw new Error('Failed to fetch mask image from URL');
//     }
    
//     const maskBuffer = Buffer.from(await maskResponse2.arrayBuffer());
//     console.log("uploading starts ....")
//     const uploadMask = await new Promise<UploadApiResponse>((resolve, reject) => {
//       const stream = cloudinary.uploader.upload_stream(
//         { folder: "rhinoplasty", resource_type: "image" },
//         (err, result) => {
//           if (err) reject(err);
//           else resolve(result as UploadApiResponse);
//         }
//       );
//       stream.end(maskBuffer);
//     });
// console.log("getting the current user .....")
    
    // 4. Store original image in DB
    
    const user = await getCurrentUser();
    let imageDbId = null;
    if (user) {
      try {
        const dbImage = await prisma.images.create({
          data: {
            url: uploadOriginal.secure_url,
            userId: user.id,
          },
        });
        imageDbId = dbImage.id;
      } catch (dbError) {
        console.error("Database error:", dbError);
        // Continue without storing in DB if there's an error
      }
    }

    // Return URLs and DB id
    return NextResponse.json({
      originalUrl: uploadOriginal.secure_url,
      maskUrl: maskImageUrl,
      originalImageId: imageDbId
    });
  } catch (error) {
    console.error("Upload-with-mask error:", error);
    return NextResponse.json({ error: "Failed to upload and generate mask" }, { status: 500 });
  }
} 